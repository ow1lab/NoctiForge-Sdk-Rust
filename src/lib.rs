use serde::{Serialize, de::DeserializeOwned};
use std::{
    collections::HashMap,
    panic::{AssertUnwindSafe, catch_unwind},
};
use std::{future::Future, marker::PhantomData};
use tokio::net::UnixListener;
use tonic::Response;

use tonic::Status;

mod action {
    tonic::include_proto!("noctiforge.action");
}

use action::{
    InvokeRequest, InvokeResult, Success,
    function_runner_service_server::{FunctionRunnerService, FunctionRunnerServiceServer},
    invoke_result::Result as IR,
};

pub use action::Problem;



#[allow(dead_code)]
pub struct Context {
    pub values: HashMap<String, String>,
}

pub async fn start<F, Fut, In, Out>(handler: F) -> Result<(), Box<dyn std::error::Error>>
where
    F: Send + Sync + Clone + 'static + Fn(In, Context) -> Fut,
    Fut: Future<Output = Result<Out, Problem>> + Send + Sync + 'static,
    In: DeserializeOwned + Send + Sync + 'static,
    Out: Serialize + Send + Sync + 'static,
{
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .init();

    struct MyService<F, Fut, In, Out>
    where
        F: Send + Sync + Clone + 'static + Fn(In, Context) -> Fut,
        Fut: Future<Output = Result<Out, Problem>> + Send + 'static,
        In: DeserializeOwned + Send + 'static,
        Out: Serialize + Send + Sync + 'static,
    {
        handler: F,
        _marker: PhantomData<(Fut, In, Out)>,
    }

    // Implement the service trait (generated by Tonic)
    #[tonic::async_trait]
    impl<F, Fut, In, Out> FunctionRunnerService for MyService<F, Fut, In, Out>
    where
        F: Send + Sync + Clone + 'static + Fn(In, Context) -> Fut,
        Fut: Future<Output = Result<Out, Problem>> + Send + 'static + std::marker::Sync,
        In: DeserializeOwned + Send + 'static + std::marker::Sync,
        Out: Serialize + Send + Sync + 'static,
    {
        async fn invoke(
            &self,
            request: tonic::Request<InvokeRequest>,
        ) -> Result<Response<InvokeResult>, Status> {
            let inner = request.into_inner();

            let input: In = serde_json::from_slice(&inner.payload)
                .map_err(|e| Status::invalid_argument(format!("Invalid input: {}", e)))?;

            let context = Context {
                values: inner.metadata,
            };

            // Call the handler safely, catching panics
            let handler_result = catch_unwind(AssertUnwindSafe({
                let handler = self.handler.clone();
                move || handler(input, context)
            }));

            let invoke_result = match handler_result {
                Ok(fut) => match fut.await {
                    Ok(out) => match serde_json::to_vec(&out) {
                        Ok(bytes) => IR::Success(Success { output: bytes }),
                        Err(e) => IR::Problem(Problem {
                            r#type: "container/serialization_failed".to_string(),
                            detail: e.to_string(),
                        }),
                    },
                    Err(problem) => IR::Problem(problem),
                },
                Err(_) => IR::Problem(Problem {
                    r#type: "container/panic_triggered".to_string(),
                    detail: "Unknown panic occurred".to_string(),
                }),
            };

            Ok(Response::new(InvokeResult {
                result: Some(invoke_result),
            }))
        }
    }

    let socket_path = "/run/app.sock";

    if std::path::Path::new(&socket_path).exists() {
        std::fs::remove_file(socket_path)?;
    }

    let listener = UnixListener::bind(socket_path)?;
    log::info!("Starting server on Unix socket: {}", socket_path);

    let svc = FunctionRunnerServiceServer::new(MyService {
        handler,
        _marker: PhantomData,
    });

    tonic::transport::Server::builder()
        .add_service(svc)
        .serve_with_incoming(tokio_stream::wrappers::UnixListenerStream::new(listener))
        .await?;

    Ok(())
}
